---
layout: post
title: 'Leetcode'
date: 2020-02-10
author: DoHerasYang
color: rgb(153,153,255)
cover: '/Pictures/CoverPage/C_C++.jpg'
tags: C C++


---

# C / C++ 面试知识点规划

>来源：牛客网以及各种自己扒的看的资料，不懂得问题，记录下的有问题的地方
>
>我太菜了 -_-

---

[TOC]

---

## 1.基础知识

### 1.1 C 与 C++的区别

**面向过程与面向对象 —— 设计思想**

>C 语言是**面向过程**(Procedure-Oriented Programming，简记为POP)的语言，面向过程的意思是分析并提出解决问题的步骤，并不关心是谁产生了影响，而是使用函数流程来解决实际的问题。“面向过程”就是汽车启动是一个事件，汽车到站是另一个事件。在编程序的时候我们关心的是某一个事件。而不是汽车本身。我们分别对启动和到站编写程序。类似的还有修理等等。面向过程并不支持面向对象的特性，比如说继承，多态，封装等等。
>
>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
>
>缺点：没有面向对象易维护、易复用、易扩展
>
>C++ 是**面向对象**的语言，相比于C语言不同的是当解决一个问题时候编译器会将问题抽象成多个对象来解决这个问题，这个问题中会包含哪些对象，每一个对象拥有具体的属性及其方法，关注的是对象整体，而不是解决问题的流程。
>
>优点: 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
>
>缺点: 性能比面向过程低

**安全性**

对于C语言来说，C++支持强制类型转换，不容易出现缓冲区溢出的漏洞(使用for循环时)，

C++中提供了更多的类型安全机制来保证程序安全:

> 1.操作符new返回的指针类型严格与对象匹配，而不是void*;
>
> 2.C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
>
> 3.引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
>
> 4.一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全;
>
> 5.C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

**编程范式**

“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。

C++是一种**多范式**的编程语言。具体来说，现代C++（11/14以后）支持“面向过程”“面向对象”“泛型”“模板元”“函数式”这五种主要的编程范式。

**泛型编程**是自STL（标准模板库）纳入到C++标准以后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。

在C++里，泛型的基础就是template关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如vector、map、sort，等等。

### 1.2 什么是封装/继承/多态 与 五大基本原则

**封装**:  信息隐藏，指的是利用抽象数据类型将数据和进行数据操作的方法结合到一起，使其成为一个不可分割的整体，使用起来像测试中的黑盒和白盒，只需要了解好封装后整体的提供的接口，系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。

优点: 1.良好的封装能够减少耦合。 2.类内部的结构可以自由修改。 3.可以对成员进行更精确的控制。 4.隐藏信息，实现细节。

**继承**: 对于继承来说，继承的对象主要是类，新的类可以继承父类的属性以及方法，但这种继承是全部的，即不能够选择性地继承父类，方便复用代码并增加实现新的新的特性，对于开发新的性能来说比较节省开发成本，但是这种继承并不是全部继承：1.子类拥有父类非private的属性和方法。2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。3.子类可以用自己的方式实现父类的方法。

缺陷: 1.父类变，子类就必须变。2.继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。3.继承是一种强耦合关系。

**多态**:  按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。类可以理解为一种封装，即会提供一种接口，多态就是将一种接口来多种实现。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。C++ 中的多态性具体体现在编译和运行两个阶段。编译时多态是静态多态，在编译时就可以确定使用的接口。运行时多态是动态多态，具体引用的接口在运行时才能确定。

> 静型多态: 静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。作用是将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。静态多态往往通过函数重载和模版（泛型编程）来实现。
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> //两个函数构成重载
> int add(int a, int b)
> {
>     cout<<"in add_int_int()"<<endl;
>     return a + b;
> }
> double add(double a, double b)
> {
>     cout<<"in add_double_doube()"<<endl;
>     return a + b;
> }
> 
> //函数模板（泛型编程）
> template <typename T>
> T add(T a, T b)
> {
>     cout<<"in func tempalte"<<endl;
>     return a + b;
> }
> 
> int main()
> {
>     cout<<add(1,1)<<endl;					//调用int add(int a, int b)
>     cout<<add(1.1,1.1)<<endl;		   	 	//调用double add(double a, double b)
>     cout<<add<char>('A',' ')<<endl;		//调用模板函数，输出小写字母a
> }
> ```

> 动态多态: 动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动态联编。作用是不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。必须使用虚函数，如果没有使用虚函数，即没有利用 C++ 多态性，则利用基类指针调用相应函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写的函数。
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> class Base
> {
> public:
>     virtual void func()
>     {
>         cout << "Base::fun()" << endl;
>     }
> };
> 
> class Derived : public Base
> {
> public:
>     virtual void func()
>     {
>       cout << "Derived::fun()" << endl;
>     }
> 
> };
> 
> int main()
> {
>     Base* b=new Derived;            //使用基类指针指向派生类对象
>     b->func();                       //动态绑定派生类成员函数func
>     
>     Base& rb=*(new Derived);        //也可以使用引用指向派生类对象
>     rb.func();                
> }
> ```

**单一职责原则SRP(Single Responsibility Principle)**

是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

**开放封闭原则OCP(Open－Close Principle)**

一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

**里式替换原则LSP(the Liskov Substitution Principle LSP)**

子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

**依赖倒置原则DIP(the Dependency Inversion Principle DIP)**

具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

**接口分离原则ISP(the Interface Segregation Principle ISP)**

模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

### 1.3 理解Static关键字



### 1.4 说几个C++/C关键字并说出其作用



### 1.5 基础问题









## 2. 算法知识





## 3. 计算机网络知识

### 3.1 NAT (Network Address Translation) 网络地址转换 - 内网

在内网中，可以任意设置内网IP地址通过代理服务器(NAT)，但基本上分为三个段。

```
A: ``10.0``.``0.0``~``10.255``.``255.255` `即``10.0``.``0.0``/``8
B:``172.16``.``0.0``~``172.31``.``255.255``即``172.16``.``0.0``/``12
C:``192.168``.``0.0``~``192.168``.``255.255` `即``192.168``.``0.0``/``16
```

内网的设备使用内网IP。通过NAT设备，转换为外网（公网ip）。

1. 静态转换。将内网设备ip，永久的映射为公网的某个合法地址。
2. 动态转换。将内网设备ip动态的、临时的映射为公网的某个ip
3. NAPT，将内网的设备ip映射到NAPT设备的某个端口上，再进一步映射为公网的某个ip。较为常用。

### 3.2 OSI模型

以太网交换机   ----------  作用在数据链路层

---

### 3.3 网络中的通信原理

> 以太网的**直通交换方式**在输入端口检测到一个 [数据包](http://baike.baidu.com/view/25880.htm) 时，检查该包的包头，获取包的目的地址，启动内部的动态查找表转换成相应的输出端口，在输入与输出交叉处接通，把数据包直通到相应的端口，实现交换功能。它只检查数据包的包头(包括7个字节的前同步码+1个字节的帧开始界定符+6个字节的目的地址共14个字节)，有时题目说明不包含前导码，即只包6个字节含目的地址。那么转发时延：6B/100Mbps=0.48us

> 通过电话线将计算机接入因特网：
>
> 1.串行线路协议SLIP
>
> 2.点对点协议PPP

### 3.3 网络中的计算题以及计算技巧

1B = 8bit   /   1Mbps = 1024Kbps=1024/8KBps=128KB/s   /   100Mbps = 12800KB/s



## 4. 数据结构

### 4.1 基础知识

> 数据结构是计算机存储、组织数据的方式，数据对象以及存在于该对象的**实例（值）**和组成实例的数据**元素之间的各种关系**。



### 4.2 什么是E-R图

E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界与概念模型。实体-联系数据模型中的联系型，存在3种一般性约束：一对一约束（联系）、一对多约束（联系）和多对多约束（联系）

### 4.3 栈

**定义**： 栈是限定尽在表尾进行插入或者删除操作的线性表。表尾端对于栈有着特殊的意义，因此不能随便地对栈进行插入工作，表头端称为栈底。不含元素的空表称为空栈。栈又称为后进先出的线性表。属于 FILO (First In Last Out)。

![栈](https://img-blog.csdn.net/20170823173711540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM1MDQzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**栈的类别**:

**顺序栈**，即栈的顺序存储结构是利用一组**地址连续的存储单元**依次存放**自栈底到栈顶的数据元素**，同时附设指针**top只是栈顶元素在顺序栈中的位置。这里以top=-1表示空栈**。

**链式栈**可以通过单链表的方式来实现，使用链式栈的**优点在于它能够克服用数组实现的顺序栈空间利用率不高**的特点，但是**需要为每个栈元素分配额外的指针空间用来存放指针域**。相比于顺序栈，链式栈通常不会出现栈满的情况。

**栈的特点**:

+ 线性表顺序存储模式的逻辑顺序与物理顺序总是一致的。但是链式表不是，因为需要额外的指针空间来存储指针域。
+ 两种存储结构并没有优劣之分，只是看在什么情况下适合哪种存储结构。对于**经常插入或删除的适合选择链式存储**，**经常查找的适合顺序存储**。
+ 线性表若采用链式存储表示时所有结点之间的存储单元地址**可连续可不连续**。
+ 二维数组是每个元素都为顺序表的顺序表 .
+ 栈中的运算只有: 插入、删除

### 4.4 堆





## 5. 操作系统

### 5.1 操作系统知识

#### 5.1.1 多进程 多线程 多任务

> 线程是指进程内的一条执行线路，或者说是进程中可执行代码的单独单元，它是操作系统的基本调度单元。
>
> 进程从主线程开始执行，进而可以创建一个或多个附加线程来执行该进程内的并发任务，这就是基于线程的多任务。

#### 5.1.2 操作系统中的堆(heap)与栈(stack)

> stack由编译器自动分配和释放,存放函数的参数值，局部变量。stack上分配的内存由系统来进行释放，一般是静态内存。
>
> heap一般由程序员分配和释放，若程序员不释放，可能会造成操作系统的内存泄露。heap 上分配的内存，系统不释放，哪怕程序退出，那一块内存还是在那里。heap一般来说是动态内存。由malloc函数分配的内存从堆上进行分配，堆上的内存一定要由`free`函数进行释放。一般来说堆如果分配的内存分配完，再继续分配就会导致程序崩溃。

### 5.2 Linux

#### 5.1.1 常用Linux命令

> **crontab命令**
>
> ```bash
> #分　 时　 日　 月　 周　 命令
> #第1列表示分钟1～59 每分钟用*或者 */1表示
> #第2列表示小时1～23（0表示0点）
> #第3列表示日期1～31
> #第4列表示月份1～12
> #第5列标识号星期0～6（0表示星期天）
> #第6列要运行的命令
> 
> #*  表示 
> #第1列时：表示每分钟都要执行一次，
> #第2列时：表示每小时都要执行一次，依次类推，
> 
> 06 03 * * 3 lp /usr/local/message | mail -s "server message" root
> 
> #每周三 03:06执行命令
> ```

> - **make config** - 纯文本界面 (最常用的选择)。 
> - **make menuconfig** - 基于文本彩色菜单和单选列表。这个选项可以加快开发者开发速度。需要安装ncurses(ncurses-devel)。 
> - **make nconfig** - 基于文本的彩色菜单。需要安装curses (libcdk5-dev)。 
> - **make xconfig** - QT/X-windows 界面。需要安装QT。 
> - **make gconfig** - Gtk/X-windows 界面。需要安装GTK。 
> - **make oldconfig** - 纯文本界面，但是其默认的问题是基于已有的本地配置文件。 
> - **make silentoldconfi****g** - 和oldconfig相似，但是不会显示配置文件中已有的问题的回答。 
> - **make olddefconfig** -和silentoldconfig相似，但有些问题已经以它们的默认值选择。 
> - **make defconfig** - 这个选项将会创建一份以当前系统架构为基础的默认设置文件。 
> - **make ${PLATFORM}defconfig** - 创建一份使用arch/$ARCH/configs/${PLATFORM}defconfig中的值的配置文件。 
> - **make allyesconfig** - 这个选项将会创建一份尽可能多的问题回答都为‘yes’的配置文件。 
> - **make allmodconfig** - 这个选项将会创建一份将尽可能多的内核部分配置为模块的配置文件。

