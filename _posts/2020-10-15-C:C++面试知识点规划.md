---
layout: post
title: 'C/C++'
date: 2020-02-10
author: DoHerasYang
color: rgb(153,153,255)
cover: '/Pictures/CoverPage/C_C++.jpg'
tags: C C++

---

# C / C++ 面试知识点规划

>来源：牛客网以及各种自己扒的看的资料，不懂得问题，记录下的有问题的地方
>
>就这样吧
>
>C/C++   前端工程师    web安全   机器学习

---

[TOC]

---

## 1.基础知识

### 1.1 C 与 C++的区别

**面向过程与面向对象 —— 设计思想**

>C 语言是**面向过程**(Procedure-Oriented Programming，简记为POP)的语言，面向过程的意思是分析并提出解决问题的步骤，并不关心是谁产生了影响，而是使用函数流程来解决实际的问题。“面向过程”就是汽车启动是一个事件，汽车到站是另一个事件。在编程序的时候我们关心的是某一个事件。而不是汽车本身。我们分别对启动和到站编写程序。类似的还有修理等等。面向过程并不支持面向对象的特性，比如说继承，多态，封装等等。
>
>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
>
>缺点：没有面向对象易维护、易复用、易扩展
>
>C++ 是**面向对象**的语言，相比于C语言不同的是当解决一个问题时候编译器会将问题抽象成多个对象来解决这个问题，这个问题中会包含哪些对象，每一个对象拥有具体的属性及其方法，关注的是对象整体，而不是解决问题的流程。
>
>优点: 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
>
>缺点: 性能比面向过程低

**安全性**

对于C语言来说，C++支持强制类型转换，不容易出现缓冲区溢出的漏洞(使用for循环时)，

C++中提供了更多的类型安全机制来保证程序安全:

> 1.操作符new返回的指针类型严格与对象匹配，而不是void*;
>
> 2.C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
>
> 3.引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
>
> 4.一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全;
>
> 5.C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

**编程范式**

“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。

C++是一种**多范式**的编程语言。具体来说，现代C++（11/14以后）支持“面向过程”“面向对象”“泛型”“模板元”“函数式”这五种主要的编程范式。

**泛型编程**是自STL（标准模板库）纳入到C++标准以后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。

在C++里，泛型的基础就是template关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如vector、map、sort，等等。

### 1.2 什么是封装/继承/多态 与 五大基本原则

**封装**:  信息隐藏，指的是利用抽象数据类型将数据和进行数据操作的方法结合到一起，使其成为一个不可分割的整体，使用起来像测试中的黑盒和白盒，只需要了解好封装后整体的提供的接口，系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。

优点: 1.良好的封装能够减少耦合。 2.类内部的结构可以自由修改。 3.可以对成员进行更精确的控制。 4.隐藏信息，实现细节。

**继承**: 对于继承来说，继承的对象主要是类，新的类可以继承父类的属性以及方法，但这种继承是全部的，即不能够选择性地继承父类，方便复用代码并增加实现新的新的特性，对于开发新的性能来说比较节省开发成本，但是这种继承并不是全部继承：1.子类拥有父类非private的属性和方法。2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。3.子类可以用自己的方式实现父类的方法。

缺陷: 1.父类变，子类就必须变。2.继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。3.继承是一种强耦合关系。

**多态**:  按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。类可以理解为一种封装，即会提供一种接口，多态就是将一种接口来多种实现。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。C++ 中的多态性具体体现在编译和运行两个阶段。编译时多态是静态多态，在编译时就可以确定使用的接口。运行时多态是动态多态，具体引用的接口在运行时才能确定。

> 静型多态: 静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。作用是将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。静态多态往往通过函数重载和模版（泛型编程）来实现。
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> //两个函数构成重载
> int add(int a, int b)
> {
>     cout<<"in add_int_int()"<<endl;
>     return a + b;
> }
> double add(double a, double b)
> {
>     cout<<"in add_double_doube()"<<endl;
>     return a + b;
> }
> 
> //函数模板（泛型编程）
> template <typename T>
> T add(T a, T b)
> {
>     cout<<"in func tempalte"<<endl;
>     return a + b;
> }
> 
> int main()
> {
>     cout<<add(1,1)<<endl;					//调用int add(int a, int b)
>     cout<<add(1.1,1.1)<<endl;		   	 	//调用double add(double a, double b)
>     cout<<add<char>('A',' ')<<endl;		//调用模板函数，输出小写字母a
> }
> ```

> 动态多态: 动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动态联编。作用是不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。必须使用虚函数，如果没有使用虚函数，即没有利用 C++ 多态性，则利用基类指针调用相应函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写的函数。
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> class Base
> {
> public:
>     virtual void func()
>     {
>         cout << "Base::fun()" << endl;
>     }
> };
> 
> class Derived : public Base
> {
> public:
>     virtual void func()
>     {
>       cout << "Derived::fun()" << endl;
>     }
> 
> };
> 
> int main()
> {
>     Base* b=new Derived;            //使用基类指针指向派生类对象
>     b->func();                       //动态绑定派生类成员函数func
>     
>     Base& rb=*(new Derived);        //也可以使用引用指向派生类对象
>     rb.func();                
> }
> ```

>重载多态和强制多态是 指**特定多态。**
>
>参数多态和包含多态是指**通用多态。**

+ **单一职责原则SRP(Single Responsibility Principle)**

是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

+ **开放封闭原则OCP(Open－Close Principle)**

一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

+ **里式替换原则LSP(the Liskov Substitution Principle LSP)**

子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

+ **依赖倒置原则DIP(the Dependency Inversion Principle DIP)**

具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

+ **接口分离原则ISP(the Interface Segregation Principle ISP)**

模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

### 1.3 理解Static关键字(静态) - 重点















### 1.4 说几个C++/C的关键字并说出其作用

+ **unsigned**: C++中输出65536。 **unsigned** 是无符号修饰符, 可以修饰int, char, long, short 如：`unsigned int i`;申明了一个无符号整型变量。

+ **violate** : Volatile，词典上的解释为：易失的；易变的；易挥发的。那么用这个关键词修饰的C/C++变量，应该也能够体现出”易变”的特征。另外的一个特性就是"不可优化性"。使用volatile修饰的变量，在使用的时候，每一次都是重新从内存中取值，而不是从寄存器中。volatile变量间的操作，是不会被编译器交换顺序的。

  > **violate** 关键词告诉编译器定义的变量是随时变化的，并且每次使用定义的变量需要从变量的地址重新读取。
  >
  > 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
  >
  > **场景**：
  >
  > + 并行设备的硬件寄存器（如：状态寄存器）
  > + 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
  > + 多线程应用中被几个任务共享的变量

+ 

### 1.5 浅拷贝与深拷贝

**环境**:

+ 当系统生成一个新的类对象时，往往会自动地构建一个构造函数如果程序员不去特意地指定类的构造函数，编译器生成一个新的对象会自动地调用一个构造函数，如果一个类的对象去实例化一个新的类对象那么会调用**拷贝构造函数**，这种拷贝构造函数定义与普通的构造函数并没有什么区别。

+ **拷贝构造函数**：

  1) **定义格式：类名（const 类名 &变量名）**

  2) 拷贝构造函数与普通的构造函数一样

  - 如果没有自定义的拷贝构造函数则系统自动生成一个默认的拷贝构造函数
  - 当采用直接初始化或复制初始化实例化对象时系统自动调用拷贝构造函数

**区别**:

+ 对于拷贝构造函数来说，对于类中存在指针成员变量，默认拷贝函数被调用时称为浅拷贝，因为它只是简单的对成员变量进行了复制操作。

**浅拷贝**:

+ 浅层复制：只复制指向类对象的指针，而不复制引用对象本身。如果没有特殊情况一般来说系统调用的是浅拷贝。
+ 如果是浅复制，修改一个对象可能会影响另外一个对象，因为是只是复制了指向的指针。

```c++
class Array
{
public:
    Array(){m_iCount=5;}
    Array(const Array &arr)
    {
        m_iCount=arr.m_iCount; // 浅拷贝只是去做数据成员的简单拷贝，并不身型新的
    }
private:
    int m_iCount;          
};
int main()
{
    Array arr1;
    Array arr2=arr1; // 调用拷贝构造函数
    return 0;
}
```

**深拷贝**:

+ 深层复制：复制引用对象本身。
+ 如果是深拷贝，修改一个对象不会影响到另外一个对象。

```c++
 1 class Array
 2 {
 3 public:
 4     Array(){m_iCount=5;m_pArr=new int[m_iCount];}
 5     Array(const Array &arr)
 6     {
 7         m_iCount=arr.m_iCount;
 8         m_pArr=new int[m_iCount]; //开辟了一个新的堆空间，所以是深拷贝，因为类对象指针所指向的数组的地址不同
 9         for(int I=0;i<m_iCount;i++)
10         {
11             m_pArr[i]=arr.m_pArr[i];
12         }
13     }
14 private:
15     int m_iCount;
16     int *m_pArr;
17 };
```



### 1.6 指针问题

**C/C++ 指针**

> **一级指针与二级指针**
>
> 一级指针就是指向普通对象的指针，就是内存地址，二级指针就是指向指针的指针，就是地址的地址
>
> ```c++
> #include<iostream>  
> using namespace std;
> 
> int main(int argc, char**argv)  
> {
> 	int a = 4;//定义一个变量a
> 	int *p = &a;//定义一个一级指针p，保存的是变量a的地址，指向a
> 	int **q = &p;//定义一个二级指针，保存的是指针p的地址，指向指针p
> }
> 
> //若有以下说明和定义，则叙述正确的是（）。
> typedef int *INTEGER;
> INTEGER p,*q;
> 
> // 其中   INTEGER其实就是基类型为 int 的指针类型
> // INTEGER 米定义两个变量p和*q，则p是基类型为int型的一级指针变量，而q是基类型为int型的二级指针变量。
> ```

> **函数中的指针**

> **C++中void和void*指针的含义**
>
> 

### 1.7 内存问题

```C++
void func() {	int *  p = new int [ 5 ];	}
// p 是 一个指针变量所以存储到了 栈中
// new 分配了一个新的堆区域
delete []p
```

#### 1.7.1 栈

**定义**:  **栈**，就是那些由**编译器在需要的时候分配**，在**不需要的时候自动清除的变量的存储区**。里面的**变量通常是局部变量、函数参数、指针变量**等。在一个进程中，位于**用户虚拟地址空间顶部的是用户栈**，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。

#### 1.7.2 堆

**定义**: **堆**，就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个 new 就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。堆可以动态地扩展和收缩。

#### 1.7.3 对比

|   类别   |                              栈                              |                              堆                              |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 管理方式 |            是由编译器自动管理，无需我们手工控制。            |     堆来说，释放工作由程序员控制，容易产生memory leak。      |
| 空间大小 |                  栈一般是有存储空间大小的。                  | 32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。 |
| 碎片问题 | 对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出。 | 频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。 |
| 生长方向 | 对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 | 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向； |
| 分配方式 | 栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 |             堆都是动态分配的，没有静态分配的堆。             |
| 分配效率 | 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 | 堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 |

堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。

对于需要分配大量的内存，堆来说比较好一点，因为堆的大小比栈来说更大一点。



### 1.7 基础问题

> **C 与 C++的内存分配问题**
>
> `new` 与 `malloc` 的区别:      `new`不仅仅是分配了内存，也创建了一个新的对象。 在 C++中可以使用`malloc`函数，但是更推荐使用`new`。

> **C/C++ 运算符号问题**
>
> ```c++
> #include <iostream>
> using namespace std;
> int main()
> {
> 	int a,b,k;
> 	k = (a=100,b=500);
> 	cout<<k;    // k == 500 
>    	return 0;
> }
> ```

> **C/C++的类问题**
>
> > **总结一下虚析构函数的作用：** 
> > （1）**如果父类的析构函数不加virtual关键字** 
> > 当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 
> > （2）**如果父类的析构函数加virtual关键字** 
> > 当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。
>
> > **构造方法是一种特殊的方法，具有以下特点。** 
> >
> > **（1）构造方法的方法名必须与类名相同。** 
> >
> > **（2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。** 
> >
> > **（3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。** 
> >
> > **（4）构造方法不能由编程人员调用，而要系统调用。** 
> >
> > **（5）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构  造器，这个构造器不执行任何代码。** 
> >
> > **（6）构造方法可以重载，以参数的个数，类型，或排列顺序区分。** 
>
> > + **类不可以多继承，而接口可以多实现**
> > + **抽象类自身可以定义成员而接口不可以**
> > + **抽象类和接口都不能被实例化**
> > + **派生类的静态函数也不能访问直接基类的成员变量**
>
> > **抽象类**
> >
> > > **虚函数**
> > >
> > > + 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
> > >
> > > + ```c++
> > >   class Shapes   //抽象类
> > >   {
> > >   protected:
> > >       int x, y;
> > >   public:
> > >       void setvalue(int d, int w=0){x=d;y=w;}
> > >       virtual void disp()=0;//纯虚函数
> > >   };
> > >   ```
> > >
> > > + 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
> >
> > + 带有纯虚函数的类称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。**抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。** 在C++中，我们可以把只能用于被继承而不能直接创建对象的类设置为抽象类（Abstract Class）。
> > + 抽象类只能用作其他类的基类，不能建立抽象类对象。
> > + 抽象类不能用作参数类型、函数返回类型或显式转换的类型。
> > + 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。
>
> > **在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。**
> >
> > ```C++
> > class A{ 
> > 
> >   private:
> > 
> >   static int count ; // 类内声明
> > 
> > };
> > int A::count = 0 ; // 类外初始化，不必再加static关键字
> > ```
> >
> > **因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。**
> >
> > **能在类中初始化的成员只有一种，那就是静态常量成员。**
> >
> > **此外，还需要注意的是声明和定义的区别：**
> >
> > **①变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。**
> >
> > **②变量声明：用于向程序表明变量的类型和名字。**
>
> > **类的封装**
> >
> > + C++通过类来实现封装性，把数据和与这些数据有关的操作封装在一个类中，或者说，类的作用是把数据和算法封装在用户声明的抽象数据类型中。

> **内联函数**
>
> 引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。
>
> - 在内联函数内**不允许使用循环语句和开关语句**；
> - 内联函数的定义**必须出现在内联函数第一次调用之前**；
> - 类结构中所在的类**说明内部定义的函数是内联函数**。
>
> **优点:**
>
> （1）通过避免函数的回调，加速了程序的执行；
>
> （2） 通过利用指令缓存，增强局部访问性；
>
> （3）使用内联可以替换重复的短代码，方便代码管理；
>
> **缺点:**
>
> （1） 由于是替换展开，因此会增大代码体量；
> （2）一旦修改内联，所有用到该内联的地方都需要重新编译；
>
> **使用场景**:
>
> + 1）需要提高程序运行效率；
> + 2）需要用内联替代宏定义来实现某些功能；
> + 3）在类中声明同时定义的成员函数，自动转化为内联函数，如果需要隐藏该函数的实现细节，则在类外定义内联；

> **宏**
>
> 在C++中，宏定义的关键词为`#define`
>
> ```C++
> #define <宏名> <字符串>
> #define <宏名> (<参数表>) <宏体> 
> 
> #define Square(x) x*x
> float temp = Square(3+3);
> //程序的本意可能是要计算6*6=36，但由于宏定义执行的是直接替换，本身并不做计算，因此实际的结果为 3+3*3+3=15
> //想要避免这个问题，只需要修改如下：
> #define Square(x) ((x)*(x))
> ```
>
> **特性**
>
> + 宏名一般用大写，且末尾不加分号。
> + 宏定义的参数是无类型的，不做语法检查，不做表达式求解，只做替换。
> + 宏定义通常在文件的最开头，可以使用
> + 宏展开使源程序变长，函数调用不会；宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。
> + 函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存。
> + 使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义，常量pi常用宏定义。
>
> **例子**:
>
> ```c++
> // 防止一个头文件被重复包含
> //******************BODYDEF_H******************
> #ifndef BODYDEF_H 
> #define BODYDEF_H 
> //头文件内容 
> #endif
> //******************BODYDEF_H******************
> 
> // 得到指定地址上的一个字节或字
> #define MEM_B( x ) ( *( (byte *) (x) ) ) 
> #define MEM_W( x ) ( *( (word *) (x) ) )
> //例如：
> int bTest = 0x123456;
> byte m = MEM_B((&bTest));/*m=0x56*/
> int n = MEM_W((&bTest));/*n=0x3456*/
> ```
>
> **ANSI标准说明了五个预定义的宏名。它们是：**
>
> **__LINE__：**在源代码中插入当前源代码行号；
>
> **__FILE__：**在源文件中插入当前源文件名；
>
> **__DATE__：**在源文件中插入当前的编译日期
>
> **__TIME__：**在源文件中插入当前编译时间；
>
> **__STDC__：**当要求程序严格遵循ANSI C标准时该标识被赋值为1；
>
> **__cplusplus：**当编写C++程序时该标识符被定义

> 

## 2. 算法知识

### 2.1 时间复杂度

> 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1) 





## 3. 计算机网络知识

### 3.1 NAT (Network Address Translation) 网络地址转换 - 内网

在内网中，可以任意设置内网IP地址通过代理服务器(NAT)，但基本上分为三个段。

```
A: ``10.0``.``0.0``~``10.255``.``255.255` `即``10.0``.``0.0``/``8
B:``172.16``.``0.0``~``172.31``.``255.255``即``172.16``.``0.0``/``12
C:``192.168``.``0.0``~``192.168``.``255.255` `即``192.168``.``0.0``/``16
```

内网的设备使用内网IP。通过NAT设备，转换为外网（公网ip）。

1. 静态转换。将内网设备ip，永久的映射为公网的某个合法地址。
2. 动态转换。将内网设备ip动态的、临时的映射为公网的某个ip
3. NAPT，将内网的设备ip映射到NAPT设备的某个端口上，再进一步映射为公网的某个ip。较为常用。

### 3.2 OSI模型

> 物理层：RJ45、CLOCK、IEEE802.3 
>
> 数据链路：PPP、FR、HDLC、VLAN、MAC 
>
> 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP
>
> 传输层：TCP、UDP、SPX
>
> 会话层：NFS、SQL、NETBIOS、RPC
>
> 表示层：JPEG、MPEG、ASII
>
> 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

> 物理层：
>
> 数据链路：以太网交换机
>
> 网络层：
>
> 传输层：
>
> 会话层：
>
> 表示层：
>
> 应用层：

---

### 3.3 网络中的通信原理

> 以太网的**直通交换方式**在输入端口检测到一个 [数据包](http://baike.baidu.com/view/25880.htm) 时，检查该包的包头，获取包的目的地址，启动内部的动态查找表转换成相应的输出端口，在输入与输出交叉处接通，把数据包直通到相应的端口，实现交换功能。它只检查数据包的包头(包括7个字节的前同步码+1个字节的帧开始界定符+6个字节的目的地址共14个字节)，有时题目说明不包含前导码，即只包6个字节含目的地址。那么转发时延：6B/100Mbps=0.48us

> 通过电话线将计算机接入因特网：
>
> 1.串行线路协议SLIP
>
> 2.点对点协议PPP

> - 网络技术基本上都追求的是**远距离**的**信息传输**、**远程通信**、**资源共享**的实现。
> - 不同的计算机网络虽然会在其**覆盖范围**、**通信媒介**、**设备种类**、**拓扑结构**等存在着或多或少的差别。
>
> 基于上述的各种**客观条件限制**以及**用户的更高主观标准要求**的实现，单一网络无法满足所有用户的新需求，对于非常复杂的系统，需要解决的问题很多并且性质各不相同。

>[TCP/IP协议](http://baike.baidu.com/view/7649.htm)，或称为TCP/IP协议栈，或互联网协议系列。
>
>TCP/IP协议栈（按[TCP/IP参考模型](http://baike.baidu.com/view/1792敏感词.htm)划分），TCP/IP分为4层，不同于OSI，他将OSI中的会话层、表示层规划到应用层。
>
>- [应用层](http://baike.baidu.com/view/239619.htm)FTP SMTP HTTP ...
>- [传输层](http://baike.baidu.com/view/239605.htm)TCP UDP
>- **IP网络层** IP ICMP IGMP
>- [网络接口层](http://baike.baidu.com/view/4022168.htm)ARP RARP[以太网](http://baike.baidu.com/view/848.htm)[令牌环](http://baike.baidu.com/view/54261.htm)FDDI ...
>
>包含了一系列构成互联网基础的[网络协议](http://baike.baidu.com/view/16603.htm)。

>RIP协议是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。
>RIP协议采用距离向量算法，在实际使用中已经较少适用。在默认情况下，RIP使用一种非常简单的度量制度：距离就是通往目的站点所需经过的链路数，取值为1~15，数值16表示无穷大。RIP进程使用**UDP的520端口**来发送和接收RIP分组。RIP分组每隔30s以广播的形式发送一次，为了防止出现“广播风暴”，其后续的的分组将做随机延时后发送。在RIP中，如果一个路由在180s内未被刷，则相应的距离就被设定成无穷大，并从路由表中删除该表项。RIP分组分为两种：请求分组和响应分组。

> 

### 3.4 网络中的计算题以及计算技巧

1B = 8bit   /   1Mbps = 1024Kbps=1024/8KBps=128KB/s   /   100Mbps = 12800KB/s



### 3.5 网络中的介质

>**双绞线：**短距离传输速度很快，成本低廉但衰减较快，不宜长距离传输。
>**微波：**无线通信的一种，覆盖广，但相较于有线传输速度慢
>**光纤：**速度很快，价格比双绞线高，适合超远距离传输，一般与双绞线互补使用

### 3.6 常用常识

> https端口号443 (SSL端口号)
>
> iptables既可以根据IP制定策略，也可以根据端口制定策略
>
> 0-1023是周知端口号
>
> 通过netstat命令，可以查看进程监听端口的情况
>
> > + 一个域名可以对应多个IP，但一次访问只可以解析一个IP;
> >
> > + 一个IP可以对应多个域名；
> >
> > + DNS服务器将域名转换成IP地址；
> >
> > + 网站可以通过输入IP直接访问。

---

## 4. 数据结构

### 4.1 基础知识

> 数据结构是计算机存储、组织数据的方式，数据对象以及存在于该对象的**实例（值）**和组成实例的数据**元素之间的各种关系**。

### 4.2 什么是E-R图

E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界与概念模型。实体-联系数据模型中的联系型，存在3种一般性约束：一对一约束（联系）、一对多约束（联系）和多对多约束（联系）

### 4.3 栈

**定义**： 栈是限定尽在表尾进行插入或者删除操作的线性表。表尾端对于栈有着特殊的意义，因此不能随便地对栈进行插入工作，表头端称为栈底。不含元素的空表称为空栈。栈又称为后进先出的线性表。属于 FILO (First In Last Out)。在C++中，在函数内部声明的所有变量都将占用栈内存。 数组元素存储在栈区。

![栈](https://img-blog.csdn.net/20170823173711540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM1MDQzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**栈的类别**:

**顺序栈**，即栈的顺序存储结构是利用一组**地址连续的存储单元**依次存放**自栈底到栈顶的数据元素**，同时附设指针**top只是栈顶元素在顺序栈中的位置。这里以top=-1表示空栈**。

**链式栈**可以通过单链表的方式来实现，使用链式栈的**优点在于它能够克服用数组实现的顺序栈空间利用率不高**的特点，但是**需要为每个栈元素分配额外的指针空间用来存放指针域**。相比于顺序栈，链式栈通常不会出现栈满的情况。

**栈的特点**:

+ 线性表顺序存储模式的逻辑顺序与物理顺序总是一致的。但是链式表不是，因为需要额外的指针空间来存储指针域。
+ 两种存储结构并没有优劣之分，只是看在什么情况下适合哪种存储结构。对于**经常插入或删除的适合选择链式存储**，**经常查找的适合顺序存储**。
+ 线性表若采用链式存储表示时所有结点之间的存储单元地址**可连续可不连续**。
+ 二维数组是每个元素都为顺序表的顺序表 .
+ 栈中的运算只有: 插入、删除

### 4.4 堆

**定义**: 链表元素在堆区进行存储



### 4.5 二叉树

>N 个节点可以构成多少个不同的二叉树？
>
>公式:  f(n) = C(2n,n)/(n+1) = (2n)!/((n+1)!n!)     ----- 卡特兰数（Catalan数）

### 4.6 链表

+ 链表的最大优点就是在插入或删除时不需要移动表的元素，仅仅需要修改一下指针或者实现什么链接的数据就可以了。

> **双向链表**
>
> 1. 双向链表的插入方法:  `p` 是待插入，`q` 是待插入链表中的节点
>    + `p->next = q ` 新插入的节点需要更新指向的下一个节点
>    + `p->pre = q->pre` 新创建的`p`指向上一个节点
>    + `q->pre = p`更新p指向的上一个节点上一个节点
>    + `q->pre->next = p` 原q的上一个指针指向新创建的p

> **队列**
>
> + 队列是先进先出的线性表





---

## 5. 操作系统

### 5.1 操作系统知识

#### 5.1.1 多进程 多线程 多任务

> 线程是指进程内的一条执行线路，或者说是进程中可执行代码的单独单元，它是操作系统的基本调度单元。
>
> 进程从主线程开始执行，进而可以创建一个或多个附加线程来执行该进程内的并发任务，这就是基于线程的多任务。
>
> 进程是动态的、多个进程可以含有相同的程序和多个进程可以并行运行

>**如何判断一个进程是否被停止或中断**
>
>+ An InterruptedException is thrown 异常被捕获  （一般通过interrupt方法 中断线程）  如果抓到一个线程  都会关紧catch里面 然后中断当前操作。
>+ The thread executes a wait() call. 线程执行了wait()方法。  线程使用了wait方法，会强行打断当前操作，（暂停状态，不会中断线程） 进入阻塞（暂停）状态，然后需要notify方法或notifyAll方法才能进入就绪状态。
>+ The thread executes a waitforID()call on a MediaTracker.线程在MediaTracker上执行了waitforID（）调用。  

#### 5.1.2 操作系统中的堆(heap)与栈(stack)

> stack由编译器自动分配和释放,存放函数的参数值，局部变量。stack上分配的内存由系统来进行释放，一般是静态内存。在函数内部声明的所有变量都将占用栈内存。
>
> heap一般由程序员分配和释放，若程序员不释放，可能会造成操作系统的内存泄露。heap 上分配的内存，系统不释放，哪怕程序退出，那一块内存还是在那里。heap一般来说是动态内存。由malloc函数分配的内存从堆上进行分配，堆上的内存一定要由`free`函数进行释放。一般来说堆如果分配的内存分配完，再继续分配就会导致程序崩溃。

> 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
>
> 全局存储区（静态存储区）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。
>
> 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

#### 5.1.3 用户操作操作系统

>**用户使用计算机的三种方式**:
>
>1.命令接口：分为联机命令接口和脱机命令接口
>
>2.程序接口：其实就是系统调用
>
>3.GUI接口：也就是图形接口

---

### 5.2 Linux

#### 5.1.1 常用Linux命令

> **crontab命令**
>
> ```bash
> #分　 时　 日　 月　 周　 命令
> #第1列表示分钟1～59 每分钟用*或者 */1表示
> #第2列表示小时1～23（0表示0点）
> #第3列表示日期1～31
> #第4列表示月份1～12
> #第5列标识号星期0～6（0表示星期天）
> #第6列要运行的命令
> 
> #*  表示 
> #第1列时：表示每分钟都要执行一次，
> #第2列时：表示每小时都要执行一次，依次类推，
> 
> 06 03 * * 3 lp /usr/local/message | mail -s "server message" root
> 
> #每周三 03:06执行命令
> ```

> **内核编译操作**
>
> - **make config** - 纯文本界面 (最常用的选择)。 
> - **make menuconfig** - 基于文本彩色菜单和单选列表。这个选项可以加快开发者开发速度。需要安装ncurses(ncurses-devel)。 
> - **make nconfig** - 基于文本的彩色菜单。需要安装curses (libcdk5-dev)。 
> - **make xconfig** - QT/X-windows 界面。需要安装QT。 
> - **make gconfig** - Gtk/X-windows 界面。需要安装GTK。 
> - **make oldconfig** - 纯文本界面，但是其默认的问题是基于已有的本地配置文件。 
> - **make silentoldconfi****g** - 和oldconfig相似，但是不会显示配置文件中已有的问题的回答。 
> - **make olddefconfig** -和silentoldconfig相似，但有些问题已经以它们的默认值选择。 
> - **make defconfig** - 这个选项将会创建一份以当前系统架构为基础的默认设置文件。 
> - **make ${PLATFORM}defconfig** - 创建一份使用arch/$ARCH/configs/${PLATFORM}defconfig中的值的配置文件。 
> - **make allyesconfig** - 这个选项将会创建一份尽可能多的问题回答都为‘yes’的配置文件。 
> - **make allmodconfig** - 这个选项将会创建一份将尽可能多的内核部分配置为模块的配置文件。

